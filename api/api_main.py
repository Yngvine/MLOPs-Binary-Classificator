"""
API main module using FastAPI for mylib functions endpoints.
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, Response
from fastapi.requests import Request
import uvicorn
import json
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST



from custom_lib import predict
from custom_lib.model import set_active_model

app = FastAPI(
    title="Rice Classification API",
    description="API endpoints for rice grain classification.",
    version="0.1.0",
)

# 2. Define Custom Metrics (Counters/Gauges)
# This tracks how many times each class (Gonen/Jasmine) is predicted
PREDICTION_COUNTER = Counter(
    "rice_predictions_total", 
    "Total number of rice predictions", 
    ["class_label"]
)

# FIX: Initialize the counter to 0 for known classes
# This ensures the metric appears in /metrics right from the start
PREDICTION_COUNTER.labels(class_label="Gonen").inc(0)
PREDICTION_COUNTER.labels(class_label="Jasmine").inc(0)

# Track active model name
ACTIVE_MODEL_GAUGE = Gauge(
    "active_model_info",
    "Info about the currently active model",
    ["model_name"]
)
# Set default
ACTIVE_MODEL_GAUGE.labels(model_name="xgboost_binary.onnx").set(1)

MODEL_F1_SCORE = Gauge(
    "model_f1_score", 
    "F1 Score of the currently deployed model"
)

MODEL_AUC_PR = Gauge(
    "model_auc_pr",
    "AUC-PR of the currently deployed model"
)

MODEL_MEAN_RECALL = Gauge(
    "model_mean_recall",
    "Mean Recall of the currently deployed model"
)


# Load F1 score from the file generated during training
try:
    with open("metrics.json", "r", encoding="utf-8") as f:
        data = json.load(f)
        f1_score = data.get("f1_score", 0.0)
        MODEL_F1_SCORE.set(f1_score)
        auc_pr = data.get("auc_pr", 0.0)
        MODEL_AUC_PR.set(auc_pr)
        mean_recall = data.get("mean_recall", 0.0)
        MODEL_MEAN_RECALL.set(mean_recall)
except FileNotFoundError:
    print("metrics.json not found. Setting default F1 score.")
    MODEL_F1_SCORE.set(0.0)
    MODEL_AUC_PR.set(0.0)
    MODEL_MEAN_RECALL.set(0.0)
templates = Jinja2Templates(directory="templates")


class RiceFeatures(BaseModel):
    Area: int
    MajorAxisLength: float
    MinorAxisLength: float
    Eccentricity: float
    ConvexArea: int
    EquivDiameter: float
    Extent: float
    Perimeter: float
    Roundness: float
    AspectRation: float
    ModelName: str = "xgboost_binary.onnx" # Optional, default to xgboost

# class ModelSwitchRequest(BaseModel):
#     model_name: str

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    # Pass the 'request' object to the template so it can access app.routes
    return templates.TemplateResponse(request=request, name="home.html")

@app.get("/metrics")
async def metrics():
    """
    Expose Prometheus metrics.
    Returns the latest metrics generated by the prometheus_client registry.
    """
    return Response(content=generate_latest(), media_type=CONTENT_TYPE_LATEST)


# REMOVED /switch_model endpoint as requested
# @app.post("/switch_model/")
# async def switch_model(request: ModelSwitchRequest):
#     ...


@app.post("/classify/")
async def classify_rice(features: RiceFeatures):
    """Classify rice grain based on features"""
    try:
        # 1. Update active model if requested (and different)
        # set_active_model handles avoiding reload if same model
        set_active_model(features.ModelName)
        
        # Update metric to reflect what model was just used
        ACTIVE_MODEL_GAUGE.labels(model_name="xgboost_binary.onnx").set(0)
        ACTIVE_MODEL_GAUGE.labels(model_name="tabnet_binary.onnx").set(0) # Potential name
        ACTIVE_MODEL_GAUGE.labels(model_name=features.ModelName).set(1)

        # Convert features to list in correct order
        feature_list = [
            features.Area,
            features.MajorAxisLength,
            features.MinorAxisLength,
            features.Eccentricity,
            features.ConvexArea,
            features.EquivDiameter,
            features.Extent,
            features.Perimeter,
            features.Roundness,
            features.AspectRation,
        ]

        pred_class = predict(feature_list)
        PREDICTION_COUNTER.labels(class_label=pred_class).inc()
        return {"predicted_class": pred_class}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e)) from e
    


if __name__ == "__main__":
    uvicorn.run("api.api_main:app", host="0.0.0.0", port=8000, reload=True)
